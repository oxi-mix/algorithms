package tinkoff;

/*
Вдоль круглого пруда с периметром ﻿KK﻿ расположены ﻿NN﻿ деревень.

﻿ii﻿-я деревня находится в ﻿A_iA
i
​
 ﻿ метрах от самой северной точки пруда по часовой стрелке.

Вы хотите посетить все ﻿NN﻿ деревень в каком-то порядке. Вы можете начать и закончить свое путешествие в любой деревне, при этом вы можете передвигаться только вдоль границы пруда.

Найдите минимальное расстояние, которое вам придется преодолеть, чтобы посетить все ﻿NN﻿ деревень.


Формат входных данных

В первой строке вводятся два числа ﻿KK﻿ и ﻿NN﻿﻿(2\leqslant K \leqslant 10^6, 2 \leqslant N \leqslant 2 \cdot 10^5) -(2⩽K⩽10
6
 ,2⩽N⩽2⋅10
5
 )−﻿

периметр пруда и количество деревень соответственно.

В следующей строке вводятся ﻿NN﻿ чисел ﻿A_i(0 \leqslant A_i < K) -A
i
​
 (0⩽A
i
​
 <K)−﻿ расстояния от самой северной точки пруда до деревень.

Гарантируется, что ﻿A_1 < A_2 < ... <A_N.A
1
​
 <A
2
​
 <...<A
N
​
 .﻿


Формат выходных данных

Выведите одно число ﻿-−﻿ минимальное расстояние, которое необходимо пройти, чтобы посетить все ﻿NN﻿ деревень.


Замечание

В первом примере можно начать путешествие в деревне 1, затем посетить деревню 2, а затем деревню 3. Суммарная длина такого путешествия будет равна 10.

Во втором примере можно начать путешествие в деревне 3, затем посетить деревню 1, а затем деревню 2. Суммарная длина такого путешествия будет равна 10.

Примеры данных
Пример 1
20 3
5 10 15
вывод
10
Пример 2
20 3
0 5 15
вывод
10

 */

import java.util.Scanner;

public class Villages {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int k = in.nextInt(); // периметр озера
        int n = in.nextInt(); // количество деревень

        int [] mass = new int[n]; // расстояние деревень
        int [] result = new int[n]; // суммарное расстояние если начинать от i деревни
        int [][] between = new int[n][n]; // расстояния между деревнями
        int res = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            mass[i] = in.nextInt();
        }

        for (int i = 0; i < n-1; i++) {
            between[i][i+1] = mass[i+1] - mass[i];
        }
        between[n-1][0] = k - mass[n-1] + mass[0];

        for (int i = 0; i < n; i++) {
            int count = n-1;

            int indexI = i;
            int indexJ = i+1 == n ? 0 : i+1;

            while (count != 0) {
                result[i] = result[i] + between[indexI][indexJ];
                count--;
                indexI = indexI+1 == n ? 0 : indexI+1;
                indexJ = indexJ+1 == n ? 0 : indexJ+1;
            }
        }

        for (int i = 0; i < n; i++) {
            if (result[i] <= res) {
                res = result[i];
            }
        }

        System.out.print(res);
    }
}
