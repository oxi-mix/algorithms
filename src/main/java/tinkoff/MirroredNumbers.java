package tinkoff;

/*
Во время разработки некоторой задачи Саша решил сгенерировать несколько новых тестов. Каждый тест Саши должен представлять собой натуральное число, не меньшее ﻿ll﻿ и не большее ﻿rr﻿. Кроме того, натуральное число в тесте обязательно должно состоять из одинаковых цифр.
Например, число ﻿999999﻿ подходит под это требование, а число ﻿123123﻿ — нет. Какое максимальное число различных тестов сможет создать Саша?

Формат входных данных
В единственной строке вводятся два натуральных числа ﻿l,rl,r﻿ ﻿(1 \leq l,r \leq 10^{18})(1≤l,r≤10
18
 )﻿— ограничения на тесты Саши.

Обратите внимания, что эти числа не вместятся в ﻿3232﻿-битный тип данных, используйте ﻿6464﻿-битный при необходимости

Формат выходных данных
Выведите одно число — количество тестов, которое может сделать Саша.

Замечание
В первом тесте Саше подходят номера ﻿[4,5,6,7 ][4,5,6,7]﻿.
Во втором тесте подходят все числа, кратные ﻿1111﻿, от ﻿1111﻿ до ﻿9999﻿.

Примеры данных
Пример 1
4  7
вывод
4
// 4 5 6 7

Пример 2
10  100
вывод
9
// 11 22 33 44 55 66 77 88 99

Пример 3
15 35
вывод
2
// 22 33

Пример 4
5 25
вывод
7
// 5 6 7 8 9 11 22

 */

import java.util.Scanner;
public class MirroredNumbers {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        Long l = in.nextLong();
        Long r = in.nextLong();

        if (!(1 <= l || l <= Math.pow(10, 18))) {
            return;
        }

        if (!(1 <= r || r <= Math.pow(10, 18))) {
            return;
        }

        /*
        * 1
        * 11
        * 111
        * 1111
        * 11111
        * */

        /*
        * 1 * i
        * */

        int count = 0;

        int l_i = 1;
        int r_i = 1;

        for (int i = 1; i <= 18; i++) {
            // i - сколько цифр будет зеркалиться

            // ...l [...] r ...
            if (l >= Math.pow(10, i) && l < Math.pow(10, i+1)) {
                l_i = i+1;
            }

            if (r <= Math.pow(10, i)) {
                r_i = i;
                break;
            }
        }

        for (long i = l_i; i <= r_i; i++ ) {

            StringBuilder oneCount = new StringBuilder();
            for (long k = 1; k <= i; k++) {
                oneCount.append("1");
            }
            Long one_l = Long.parseLong(oneCount.toString());

            long j = 1;

            while ((j * one_l) <= r && (j * one_l) < Math.pow(10, i)) {
                if ((j * one_l) >= l) {
                    count++;
                }
                j++;
            }
        }

        System.out.print(count);
    }
}
