package tinkoff;


/*
На физкультуре происходит разбиение по двум командам. Ребята выстроены в шеренгу, у каждого из них есть свой рост ﻿a_ia
i
 ﻿ Разбиение по командам произойдет по принципу «четный-нечетный» — все школьники с четным ростом отправляются в одну команду, а нечетные — в другую.
В отличие от привычного урока, ребята не выстроились по росту. Вместо привычного порядка они встали случайно. Теперь физрук Яша смотрит на шеренгу и думает — может ли ровно одна пара учеников поменяться местами так, чтобы команды оказались такими же, как и по принципу «первый-второй». Иначе говоря, он хочет получить такой порядок, при котором все ученики с четным ростом стоят на четных позициях, а с нечетным — на нечетных.
Помогите Яше найти нужную замену.

Формат входных данных
В первой строке находится число ﻿n(2 \leq n \leq 1000)n(2≤n≤1000)﻿ — количество учеников в шеренге.
В следующей строке находится ﻿nn﻿ натуральных чисел ﻿a_i(1\leq a_i \leq 10^9)a
i
​ (1≤a
i​
 ≤10
9
 )﻿ — рост учеников.
Формат выходных данных
В единственной строке выведите ﻿ii﻿ и ﻿jj﻿ — номера элементов, которые нужно поменять местами, чтобы добиться заданного условия ﻿(1 \leq i , j \leq n , i \ne j)(1≤i,j≤n,i
​
 =j)﻿. Если ответов несколько — разрешается вывести любой.
Если не существует способа поменять два элемента местами — выведите ﻿-1 -1−1−1﻿.

Замечания
В первом примере хотя бы один ученик с четным ростом будет стоять на нечетной позиции. Во втором тесте замена приведет к неправильному состоянию.
В третьем тесте из условия замена приведет шеренгу к валидному состоянию ﻿[1,2][1,2]﻿.

Примеры данных
Пример 1
4
2  1  4  6
-1  -1
Пример 2
2
1  2
-1  -1
Пример 3
2
2  1
1  2

*/
import java.util.Scanner;

public class RoadsAndCities {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = in.nextInt(); // количество учеников

        if (!(2 <= n || n <= 1000)) {
            return;
        }

        int [] mass = new int[n]; // рост учеников
        int [] result = new int[n]; // результат рост учеников

        for (int i = 0; i < n; i++) {
            mass[i] = in.nextInt();
            if (!(1 <= mass[i] || mass[i] <= Math.pow(10, 9))) {
                return;
            }
        }

        int countPair = n / 2; // количество пар
        for (int i = 0; i < countPair; i++) {
            if (mass[i]%2 != 0 && mass[i+1]%2 == 0) {
                // невозможно поменять местами т.к. 1 - нечетный, 2 четный
                System.out.print("-1 -1");
                return;
            } else {
                result[2 * i] = mass[(2 * i) + 1];
                result[(2 * i) + 1] = mass[2 * i];
            }
        }

        for (int i = 0; i < n; i++) {
            System.out.print(result[i] + " ");
        }
    }
}
