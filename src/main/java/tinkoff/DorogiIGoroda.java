package tinkoff;

import java.util.Scanner;

/*
В одном государстве существует ﻿NN﻿ городов, связанных двухсторонними дорогами. Изначально для каждой пары городов существовала дорога, соединяющая их напрямую. Однако потом вышел указ, по которому ﻿MM﻿

дорог были разрушены. Были разрушены дороги между городами ﻿U_1U
1
​
 ﻿ и ﻿V_1,U_2V
1
​
 ,U
2
​
 ﻿ и ﻿V_2V
2
​
 ﻿, и так далее.

Вам стало интересно, сколько существует способов совершить круговое путешествие длины ﻿KK﻿ из города 1: начать путь в городе 1, проехать ровно по ﻿KK﻿

дорогам и вернуться в город 1.

Более формально, круговым путешествием длины ﻿KK﻿из города 1 называется такая последовательность городов ﻿A_1,A_2,...,A_K, A_{K+1}A
1
​
 ,A
2
​
 ,...,A
K
​
 ,A
K+1
​
 ﻿, что города ﻿A_iA
i
​
 ﻿ и ﻿A_{i+1}A
i+1
​
 ﻿ ﻿(1 \leqslant i \leqslant K)(1⩽i⩽K)﻿ соединены дорогой и ﻿A_1=A_{K+1}=1A
1
​
 =A
K+1
​
 =1﻿. Вам нужно найти количество различных круговых путешествий длины ﻿KK﻿. Два путешествия ﻿AA﻿

и ﻿BB﻿ длины ﻿KK﻿считаются различными, если найдется такое ﻿jj﻿, что ﻿1 \leqslant j \leqslant K+11⩽j⩽K+1﻿ и ﻿A_i \ne B_j.A
i
​


​
 =B
j
​
 .﻿

Так как это количество может быть большим, выведите его по модулю

998244353.


Формат входных данных

В первой строке вводятся три числа ﻿N, M, K(2 \leqslant N,K \leqslant 5000,0 \leqslant M \leqslant min(\frac{N_*(N-1)}{2},5000)).N,M,K(2⩽N,K⩽5000,0⩽M⩽min(
2
N
∗
​
 (N−1)
​
 ,5000)).﻿

В следующих ﻿MM﻿ строках вводятся по два числа ﻿UU﻿ и ﻿V(1 \leqslant U < V \leqslant N) -V(1⩽U<V⩽N)−﻿ описания удаленных дорог.


Формат выходных данных

Выведите одно число ﻿-−﻿ ответ на задачу по модулю 998244353.


Замечание

В первом примере существуют 4 различных путешествия:

(1; 2; 1; 2; 1)
(1; 2; 1; 3; 1)
(1; 3; 1; 2; 1)
(1; 3; 1; 3; 1)
Примеры данных
Пример 1
3 1 4
2 3
вывод
4
Пример 2
3 3 3
1 2
1 3
2 3
вывод
0
Пример 3
5 3 100
1 2
4 5
2 3
вывод
428417047

 */
public class DorogiIGoroda {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt(); // количество городов
        int m = in.nextInt(); // количество разрушенных дорог
        int k = in.nextInt(); // сколько дорог нужно проехать

        int[][] street = new int[n+1][n+1]; // какие дороги вообще есть
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (i != j) {
                    street[i][j] = 1;
                }
            }
        }

//        int[][] dropStreet = new int[m][2];
        // между какими городами были разрушены дороги
        for (int i = 0; i < m; i++) {
            int a = in.nextInt();
            int b = in.nextInt();
            street[a][b] = 0;
        }

        // https://inf-ege.sdamgia.ru/test?theme=203




    }
}
